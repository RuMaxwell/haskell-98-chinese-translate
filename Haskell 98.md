# Haskell 98

## 1    介绍

Haskell 是非领域性、纯函数式的编程语言，吸收了诸多近期编程语言设计的灵感。Haskell 提供高阶函数、*非严格的语义 (non-strict semantics)*、静态多态类型 (static polymorphic typing)、用户自定义计算类型、模式匹配、列表推断、模块系统、monadic的输入输出系统，还有一系列丰富的基础数据类型，包括列表、数组、任意精度和固定精度的整型，和浮点数。Haskell 是多年对于非严格函数式编程语言的研究的巅峰产物和凝结。

### 1.2    Haskell 核心语言

Haskell 吸收了许多流行的语法糖，它们可以被转化成为更简单的语法结构。如果将这种转换进行到底，得到的语言便是 Haskell 的核心语言。

Haskell 核心语言并未被形式化定义，但它可以向 Haskell 的实现者提供很好的思路。

### 1.3    值和类型

一个表达式可被计算为一个值，且具有一个静态的类型。值和类型在 Haskell 中是决然分离的。然而，Haskell 的类型系统允许多种自定义数据类型，并且不仅支持参数化多态，还支持 ad hoc 的多态，或称作 overloading（使用类型类）。

Haskell 中的错误在语义上等同于 _|_。技术上，错误与非终结符不可区分，所以语言本身并未采用任何机制来检测和应对错误。然而，Haskell 的实现会设法提供有用的错误信息。见 3.1 节。

### 1.4    命名空间

Haskell 有六种名字，代表【变量】和【构造器】的值、【类型参数】、【类型名称】、【类型类】是类型系统的实体，还有【模块名称】。名称具有以下限制：

1. 变量和类型参数的名字必须以小写字母或下划线开头，其他四种名字必须以大写字母开头；
2. 类型名必须不能与类型类的名字相同。

除此之外没有别的限制。在同一个名字域中，`Int` 既是一个模块的名字，又是一个类型类和类型的名字。

## 2    词法结构

在本章节，我们描述 Haskell 底层的词法结构。

### 2.1    符号约定

[pattern]     可省

{pattern}     重复零次或多次

(pattern)      将内容作为一个整体

pat<sub>1</sub> | pat<sub>2</sub>  多选一

pat<sub>&lt;pat'&gt;</sub>       差集—— pat 的生成元集合减去 pat' 的生成元集合

`fibonacci` 用等宽字体表示的终结符



由于本节所介绍的是词法结构，所有空白符都是被显式写出的，在两个并列相邻的符号之间没有任何默认的空格。我们使用类似 BNF 的语法来表示规则，例如

nonterm    ->  alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>

必须注意区分元符号（|、 [...] 等）和终结符符号（使用等宽字体的 `|`、`[...]`）。

Haskell 使用 Unicode 字符集。Haskell 编译器应当尽可能更新以使用最新的 Unicode 标准。

### 2.2    词法程序结构

程序     ->  { 词 | 空白符串 }

词         ->  具权(qualified)变量标识符 | 具权类型标识符 | 具权符号变量标识符

​               | 具权符号类型标识符 |  字面量 | 特殊符号 | 保留运算符 | 保留标识符 

字面量  ->  整数字面量 | 浮点数字面量 | 字符字面量 | 字符串字面量

特殊符号 ->  `(` | `)` | `,` | `;` | `[` | `]` | `` ` `` | `{` | `}`

空白符串  ->  空白的东西 { 空白的东西 }

空白的东西 ->  空白字符 | 注释 | 多行注释

空白字符 ->  换行 | 纵向制表符 | 空格 | 制表符 | Unicode空白字符

换行      ->  CRLF | CR | LF | FF (form feed)

注释      ->  若干横杠 [ 任何字符<sub>&lt;符号&gt;</sub> {任何字符} ] 换行

​    *注：任意多个横杠接任和非符号的字符开启行内注释。*

若干横杠 ->  `--` { `-` }

开注释  ->  `{-`

关注释  ->  `-}`

多行注释 -> 开注释 任意注释字串 { 多行注释 任意注释字串 } 关注释

​    *注：这意味着 Haskell 多行注释可以嵌套。多行注释的英文原文是 nested comment，即可嵌入的注释*

任意注释字串 ->  { 任意注释字符 }<sub>&lt;{ 任意注释字符 } ( 开注释 | 闭注释  ) { 任意注释字符 }&gt;</sub>

任意注释字符 ->  可打印字符 | 空白字符

任何字符 ->  可打印字符 | 空白字符 | 制表符

可打印字符 ->  小写字母 | 大写字母 | 符号 | 数字 | 特殊符号 | `:` | `"` | `'`

小写字母 -> ASCII小写字母 | Unicode小写字母 | `_`

大写字母 -> ASCII大写字母 | Unicode大写字母

符号     -> ASCII符号 | Unicode符号<sub>&lt;特殊符号 | `_` | `:` | `"` | `'` &gt;</sub>

ASCII符号 -> `!` | `#` | `$` | `%` | `&` | `*` | `+` | `.` | `/` | `<` | `=` | `>` | `?` | `@`

​                   | `\` | `^` | `|` | `-` | `~`

数码    ->  ASCII数码 | Unicode数码

八进制数码 -> `0` | `1` | ... | `7`

十六进制数码 -> 数字 | `A` | ... | `F` | `a` | ... | `f`



词法分析应当使用“最大适合度”规则：每一次匹配，都应当读取最长可能的满足 *词* 这一条规则的词法。所以，尽管 `case` 是一个保留标识符，但 `cases` 不是。相似地，尽管 `=` 是保留运算符，但 `==` 和 `"=` 不是。

任何一种空白符都是不同词法单元之间合法的分隔符。

任何不在 *任何字符* 中的字符都是不合法的，应当导致词法错误。

>  注：字符串和单行注释中包含的 `-}` 会中断前面的多行注释。位于字符串或单行注释中的 `{-` 不会开启多行注释，因为它包含在另一个合法的词法中。

### 2.4    标识符和运算符

变量标识符    ->  ( 小写字母 {小写字母 | 大写字母 | 数字 | `'` } )<sub>&lt;保留标识符&gt;</sub>

类型标识符    ->  大写字母 {小写字母 | 大写字母 | 数字 | `'`}

保留标识符    ->  `case` | `class` | `data` | `default` | `deriving` | `do` | `else`

​                        |  `if` | `import` | `in` | `infix` | `infixl` | `infixr` | `instance`

​                        |  `let` | `module` | `newtype` | `of` | `then` | `type` | `where` | `_`

符号变量标识符 ->  ( 符号 {符号 | `:`} )<sub>&lt;保留运算符 | 若干横杠&gt;</sub>

符号类型标识符 ->  (`:` {符号 | `:`})<sub>&lt;保留运算符&gt;</sub>

保留运算符    ->  `..` | `:` | `::` | `=` | `\` | `|` | `<-` | `->` | `@` | `~` | `=>`

除了特殊的负号语法规则，所有运算符都是中缀的。当然，运算符可以用括号括起而当作一个 *section*，产生部分应用的运算符。所有标准中缀运算符都只是预定义的符号，可以被重新绑定。



由词法分类到前述的六种名字类型如下所示：

| -          | ->   | -        |
| ---------- | ---- | -------- |
| 变量标识符 | ->   | 变量     |
| 类型标识符 | ->   | 构造器   |
| 变量标识符 | ->   | 类型参数 |
| 类型标识符 | ->   | 类型名称 |
| 类型标识符 | ->   | 类型类   |
| 类型标识符 | ->   | 模块名称 |

只有变量和构造器具有中缀形式，其他没有。



具权(qualified)名称：变量、构造器、类型名称和类型类可以具有一个模块名作为前缀：

| -              | ->   | -                           |
| -------------- | ---- | --------------------------- |
| 具权变量       | ->   | [模块标识符 `.`] 变量       |
| 具权构造器     | ->   | [模块标识符 `.`] 构造器     |
| 具权类型名     | ->   | [模块标识符 `.`] 类型名     |
| 具权类型参数   | ->   | [模块标识符 `.`] 类型参数   |
| 具权符号变量   | ->   | [模块标识符 `.`] 符号变量   |
| 具权符号构造器 | ->   | [模块标识符 `.`] 符号构造器 |

因为具权名称是一个单独的词法，在模块标识符和名称之间不允许有空白符。部分示例如下：

| 写法  | 词法分析结果             |
| ----- | ------------------------ |
| `f.g` | `f`  `.`  `g` （三个词） |
| `F.g` | `F.g` （具权的 `g`）     |
| `f..` | `f`  `..` （两个词）     |
| `F..` | `F..` （具权的 `.`）     |
| `F.`  | `F`  `.` （两个词）      |

> 注：之所以 Haskell 可以不用区分 qualified 语法和 `.` 运算符，就是因为 qualified 的第一个名字一定是大写字母开头的模块名。

权不会改变一个名字的语法性质，例如 `Prelude.+` 是一个与 Prelude 模块中的`+` 具有相同结合性的中缀符号。

### 2.5    数字字面量

十进制数  ->  数码 {数码}

八进制数  ->  八进制数码 {八进制数码}

十六进制数  ->  十六进制数码 {十六进制数码}

整数字面量  ->  十进制数 

​                         |  `0o` 八进制数 | `0O` 八进制数

​                         | `0x` 十六进制数 | `0X` 十六进制数

> 注：`0` 是零，`o` 是小写o，`O` 是大写O。

浮点数字面量  ->  数码 `.` 数码 [指数]

指数  ->  (`e` | `E`) [`+` | `-`] 数码



为避免 `.` 的歧义，浮点数字面量中，小数点的前后必须都有数字。负数将在 3.4 节讨论。数字字面量的类型将在 6.4.1 节讨论。

### 2.6    字符和字符串字面量

字符字面量  ->  `'` (可打印字符<sub>&lt;`'` | `\`&gt;</sub> | 空格 | 转义字符<sub>&lt;`\&`&gt;</sub>) `'`

字符串字面量  ->  `"` {可打印字符<sub>&lt;`"` | `\`&gt;</sub> | 空格 | 转义字符 | gap } `"`

转义字符  ->  `\` ( 特殊转义 | ASCII控制字符 | 十进制数 | `o` 八进制数 | `x` 十六进制数 )

特殊转义  ->  `a` | `b` | `f` | `n` | `r` | `t` | `v` | `\` | `"` | `'` | `&`

ASCII控制字符  ->  `^` 控制符号 | `NUL` | `SOH` | `STX` | `ETX` | `EOT` | `ENQ`

​                               |  `ACK` | `BEL` | `BS` | `HT` | `LF` | `VT` | `FF` | `CR` | `SO` | `SI`

​                               |  `DLE` | `DC1` | `DC2` | `DC3` | `DC4` | `NAK` | `SYN` | `ETB`

​                               |  `CAN` | `EM` | `SUB` | `ESC` | `FS` | `GS` | `RS` | `US` | `SP` | `DEL`

控制符号  ->  ASCII大字符 | @ | `[` | `\` | `]` | `^` | `_`

gap  ->  `\` 空白字符 {空白字符} `\`



注意，以上包含一些隐含的冲突情况。由于最大匹配原则，`"\SOH"` 会是长度为 1 的字符串，而不是 `'\SO'` 和 `'H'` 组成的字符串。但万一想要输入 `'\SO'` 和 `'H'` 怎么办呢？不是一定要分开写，可以使用特殊空字符 `'\&'`。上述的情况可以写成 `"\SO\&H"`，它的长度为 2。而 `"\&"` 等同于 `""`，`'\&'` 不合法。更多关于等效字符串的说明见 6.1.2 节。

> 注：`"\12" ++ "3"` 并不需要写成 `"\12\&3"`，不足位数的数字转义字符，可在前面补足够的 `0`，即 `"\0123"`。保持这种习惯是好的。

字符串中的“gap”是一串被两个反斜杠 `\` 包围的空白字符，整个 gap 都会被忽略。这让你能在字符串中换行，如：

```Haskell
"这里有一个反斜杠 \\ 还有一个数字转义\
	\字符 \137，，和一个控制字符 \^X。"
```

字符串是字符列表的语法糖。

### 2.7    代码布局

Haskell 的语法分析依赖一系列大括号和分号，但编写程序时几乎可以全部忽略，转而通过代码布局来推断。这种特性允许你使用依赖布局方式和不依赖布局方式的两种风格的代码，甚至可以混在同一段程序中。因为布局不是必需的，其它语言的程序可以比较简单地生成 Haskell 程序。

代码布局的结果可以完全依赖分析布局本身并添加大括号和分号来产生。生成的结果不再依赖布局。

不严谨地说，插入大括号和分号的规则如下。任何一个后面不跟大括号的 `where`、`let`、`do`、`of` 关键字后，都需要遵守布局规范。这些关键字的下一个词（无论是否在新行）的缩进（即一行开头的空白符串，包括注释的长度）会被暂存，并紧接着那个关键字后面插入一个大括号。对于接下来的每一行，如果它有更多的缩进，那么上一行的最后一个部分（一个“部分”比较类似一个语句）会被延续（不插入任何东西）；如果缩进相同，那么一个新的部分开始（插入分号）；如果缩进更少，则这个布局块结束，插入一个反大括号 `}`。那个紧接在 `where`、`let`、`do`、`of` 关键字后的非大括号的词的缩进，如果没换行，它前面的代码也视为缩进。如果明确使用了大括号，那么里面的代码不会做任何布局检查。

更准确的定义见 9.3 节。

> 注：不要混用空格和制表符来缩进 Haskell 代码，最好全部用空格。也不要在缩进里面写注释。Haskell 处理相同缩进的原则是保证两行的开始位置在任何编辑器里都一致，所以混用 Tab 和空格可能会造成很麻烦的后果。就算两行缩进的 Tab 总数、空格总数都相等，顺序不一样也不一定能通过编译。

示例程序

```Haskell
module AStack( Stack, push, pop, top, size ) where
data Stack a = Empty 
             | MkStack a (Stack a)

push :: a -> Stack a -> Stack a
push x s = MkStack x s

size :: Stack a -> Int
size s = length (stkToLst s)  where
           stkToLst  Empty         = []
           stkToLst (MkStack x s)  = x:xs where xs = stkToLst s

pop :: Stack a -> (a, Stack a)
pop (MkStack x s)
  = (x, case s of r -> i r where i x = x) -- (pop Empty) is an error

top :: Stack a -> a
top (MkStack x s) = x                     -- (top Empty) is an error
```

布局分析后

```Haskell
module AStack( Stack, push, pop, top, size ) where
{data Stack a = Empty 
             | MkStack a (Stack a)

;push :: a -> Stack a -> Stack a
;push x s = MkStack x s

;size :: Stack a -> Int
;size s = length (stkToLst s)  where
           {stkToLst  Empty         = []
           ;stkToLst (MkStack x s)  = x:xs where {xs = stkToLst s

}};pop :: Stack a -> (a, Stack a)
;pop (MkStack x s)
  = (x, case s of {r -> i r where {i x = x}}) -- (pop Empty) is an error

;top :: Stack a -> a
;top (MkStack x s) = x                        -- (top Empty) is an error
}
```

