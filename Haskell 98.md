# Haskell 98

## 1    介绍

Haskell 是非领域性、纯函数式的编程语言，吸收了诸多近期编程语言设计的灵感。Haskell 提供高阶函数、*非严格的语义 (non-strict semantics)*、静态多态类型 (static polymorphic typing)、用户自定义计算类型、模式匹配、列表推断、模块系统、monadic的输入输出系统，还有一系列丰富的基础数据类型，包括列表、数组、任意精度和固定精度的整型，和浮点数。Haskell 是多年对于非严格函数式编程语言的研究的巅峰产物和凝结。

### 1.2    Haskell 核心语言

Haskell 吸收了许多流行的语法糖，它们可以被转化成为更简单的语法结构。如果将这种转换进行到底，得到的语言便是 Haskell 的核心语言。

Haskell 核心语言并未被形式化定义，但它可以向 Haskell 的实现者提供很好的思路。

### 1.3    值和类型

一个表达式可被计算为一个值，且具有一个静态的类型。值和类型在 Haskell 中是决然分离的。然而，Haskell 的类型系统允许多种自定义数据类型，并且不仅支持参数化多态，还支持 ad hoc 的多态，或称作 overloading（使用类型类）。

Haskell 中的错误在语义上等同于 \_|\_。技术上，错误与非终结符不可区分，所以语言本身并未采用任何机制来检测和应对错误。然而，Haskell 的实现会设法提供有用的错误信息。见 3.1 节。

### 1.4    命名空间

Haskell 有六种名字，代表【变量】和【构造器】的值、【类型参数】、【类型名称】、【类型类】是类型系统的实体，还有【模块名称】。名称具有以下限制：

1. 变量和类型参数的名字必须以小写字母或下划线开头，其他四种名字必须以大写字母开头；
2. 类型名必须不能与类型类的名字相同。

除此之外没有别的限制。在同一个名字域中，`Int` 既是一个模块的名字，又是一个类型类和类型的名字。

## 2    词法结构

在本章节，我们描述 Haskell 底层的词法结构。

### 2.1    符号约定

[pattern]     可省

{pattern}     重复零次或多次

(pattern)      将内容作为一个整体

pat<sub>1</sub> | pat<sub>2</sub>  多选一

pat<sub>&lt;pat'&gt;</sub>       差集—— pat 的生成元集合减去 pat' 的生成元集合

`fibonacci` 用等宽字体表示的终结符



由于本节所介绍的是词法结构，所有空白符都是被显式写出的，在两个并列相邻的符号之间没有任何默认的空格。我们使用类似 BNF 的语法来表示规则，例如

nonterm    ->  alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>

必须注意区分元符号（|、 [...] 等）和终结符符号（使用等宽字体的 `|`、`[...]`）。

Haskell 使用 Unicode 字符集。Haskell 编译器应当尽可能更新以使用最新的 Unicode 标准。

### 2.2    词法程序结构

程序     ->  { 词 | 空白符串 }

词         ->  具权(qualified)变量标识符 | 具权类型标识符 | 具权符号变量标识符

​               | 具权符号类型标识符 |  字面量 | 特殊符号 | 保留运算符 | 保留标识符 

字面量  ->  整数字面量 | 浮点数字面量 | 字符字面量 | 字符串字面量

特殊符号 ->  `(` | `)` | `,` | `;` | `[` | `]` | `` ` `` | `{` | `}`

空白符串  ->  空白的东西 { 空白的东西 }

空白的东西 ->  空白字符 | 注释 | 多行注释

空白字符 ->  换行 | 纵向制表符 | 空格 | 制表符 | Unicode空白字符

换行      ->  CRLF | CR | LF | FF (form feed)

注释      ->  若干横杠 [ 任何字符<sub>&lt;符号&gt;</sub> {任何字符} ] 换行

​    *注：任意多个横杠接任和非符号的字符开启行内注释。*

若干横杠 ->  `--` { `-` }

开注释  ->  `{-`

关注释  ->  `-}`

多行注释 -> 开注释 任意注释字串 { 多行注释 任意注释字串 } 关注释

​    *注：这意味着 Haskell 多行注释可以嵌套。多行注释的英文原文是 nested comment，即可嵌入的注释*

任意注释字串 ->  { 任意注释字符 }<sub>&lt;{ 任意注释字符 } ( 开注释 | 闭注释  ) { 任意注释字符 }&gt;</sub>

任意注释字符 ->  可打印字符 | 空白字符

任何字符 ->  可打印字符 | 空白字符 | 制表符

可打印字符 ->  小写字母 | 大写字母 | 符号 | 数字 | 特殊符号 | `:` | `"` | `'`

小写字母 -> ASCII小写字母 | Unicode小写字母 | `_`

大写字母 -> ASCII大写字母 | Unicode大写字母

符号     -> ASCII符号 | Unicode符号<sub>&lt;特殊符号 | `_` | `:` | `"` | `'` &gt;</sub>

ASCII符号 -> `!` | `#` | `$` | `%` | `&` | `*` | `+` | `.` | `/` | `<` | `=` | `>` | `?` | `@`

​                   | `\` | `^` | `|` | `-` | `~`

数码    ->  ASCII数码 | Unicode数码

八进制数码 -> `0` | `1` | ... | `7`

十六进制数码 -> 数字 | `A` | ... | `F` | `a` | ... | `f`



词法分析应当使用“最大适合度”规则：每一次匹配，都应当读取最长可能的满足 *词* 这一条规则的词法。所以，尽管 `case` 是一个保留标识符，但 `cases` 不是。相似地，尽管 `=` 是保留运算符，但 `==` 和 `"=` 不是。

任何一种空白符都是不同词法单元之间合法的分隔符。

任何不在 *任何字符* 中的字符都是不合法的，应当导致词法错误。

>  注：字符串和单行注释中包含的 `-}` 会中断前面的多行注释。位于字符串或单行注释中的 `{-` 不会开启多行注释，因为它包含在另一个合法的词法中。

### 2.4    标识符和运算符

变量标识符    ->  ( 小写字母 {小写字母 | 大写字母 | 数字 | `'` } )<sub>&lt;保留标识符&gt;</sub>

类型标识符    ->  大写字母 {小写字母 | 大写字母 | 数字 | `'`}

保留标识符    ->  `case` | `class` | `data` | `default` | `deriving` | `do` | `else`

​                        |  `if` | `import` | `in` | `infix` | `infixl` | `infixr` | `instance`

​                        |  `let` | `module` | `newtype` | `of` | `then` | `type` | `where` | `_`

符号变量标识符 ->  ( 符号 {符号 | `:`} )<sub>&lt;保留运算符 | 若干横杠&gt;</sub>

符号类型标识符 ->  (`:` {符号 | `:`})<sub>&lt;保留运算符&gt;</sub>

保留运算符    ->  `..` | `:` | `::` | `=` | `\` | `|` | `<-` | `->` | `@` | `~` | `=>`

除了特殊的负号语法规则，所有运算符都是中缀的。当然，运算符可以用括号括起而当作一个 *section*，产生部分应用的运算符。所有标准中缀运算符都只是预定义的符号，可以被重新绑定。



由词法分类到前述的六种名字类型如下所示：

| -          | ->   | -        |
| ---------- | ---- | -------- |
| 变量标识符 | ->   | 变量     |
| 类型标识符 | ->   | 构造器   |
| 变量标识符 | ->   | 类型参数 |
| 类型标识符 | ->   | 类型名称 |
| 类型标识符 | ->   | 类型类   |
| 类型标识符 | ->   | 模块名称 |

只有变量和构造器具有中缀形式，其他没有。



具权(qualified)名称：变量、构造器、类型名称和类型类可以具有一个模块名作为前缀：

| -              | ->   | -                           |
| -------------- | ---- | --------------------------- |
| 具权变量       | ->   | [模块标识符 `.`] 变量       |
| 具权构造器     | ->   | [模块标识符 `.`] 构造器     |
| 具权类型名     | ->   | [模块标识符 `.`] 类型名     |
| 具权类型参数   | ->   | [模块标识符 `.`] 类型参数   |
| 具权符号变量   | ->   | [模块标识符 `.`] 符号变量   |
| 具权符号构造器 | ->   | [模块标识符 `.`] 符号构造器 |

因为具权名称是一个单独的词法，在模块标识符和名称之间不允许有空白符。部分示例如下：

| 写法  | 词法分析结果             |
| ----- | ------------------------ |
| `f.g` | `f`  `.`  `g` （三个词） |
| `F.g` | `F.g` （具权的 `g`）     |
| `f..` | `f`  `..` （两个词）     |
| `F..` | `F..` （具权的 `.`）     |
| `F.`  | `F`  `.` （两个词）      |

> 注：之所以 Haskell 可以不用区分 qualified 语法和 `.` 运算符，就是因为 qualified 的第一个名字一定是大写字母开头的模块名。

权不会改变一个名字的语法性质，例如 `Prelude.+` 是一个与 Prelude 模块中的`+` 具有相同结合性的中缀符号。

### 2.5    数字字面量

十进制数  ->  数码 {数码}

八进制数  ->  八进制数码 {八进制数码}

十六进制数  ->  十六进制数码 {十六进制数码}

整数字面量  ->  十进制数 

​                         |  `0o` 八进制数 | `0O` 八进制数

​                         | `0x` 十六进制数 | `0X` 十六进制数

> 注：`0` 是零，`o` 是小写o，`O` 是大写O。

浮点数字面量  ->  数码 `.` 数码 [指数]

指数  ->  (`e` | `E`) [`+` | `-`] 数码



为避免 `.` 的歧义，浮点数字面量中，小数点的前后必须都有数字。负数将在 3.4 节讨论。数字字面量的类型将在 6.4.1 节讨论。

### 2.6    字符和字符串字面量

字符字面量  ->  `'` (可打印字符<sub>&lt;`'` | `\`&gt;</sub> | 空格 | 转义字符<sub>&lt;`\&`&gt;</sub>) `'`

字符串字面量  ->  `"` {可打印字符<sub>&lt;`"` | `\`&gt;</sub> | 空格 | 转义字符 | gap } `"`

转义字符  ->  `\` ( 特殊转义 | ASCII控制字符 | 十进制数 | `o` 八进制数 | `x` 十六进制数 )

特殊转义  ->  `a` | `b` | `f` | `n` | `r` | `t` | `v` | `\` | `"` | `'` | `&`

ASCII控制字符  ->  `^` 控制符号 | `NUL` | `SOH` | `STX` | `ETX` | `EOT` | `ENQ`

​                               |  `ACK` | `BEL` | `BS` | `HT` | `LF` | `VT` | `FF` | `CR` | `SO` | `SI`

​                               |  `DLE` | `DC1` | `DC2` | `DC3` | `DC4` | `NAK` | `SYN` | `ETB`

​                               |  `CAN` | `EM` | `SUB` | `ESC` | `FS` | `GS` | `RS` | `US` | `SP` | `DEL`

控制符号  ->  ASCII大字符 | @ | `[` | `\` | `]` | `^` | `_`

gap  ->  `\` 空白字符 {空白字符} `\`



注意，以上包含一些隐含的冲突情况。由于最大匹配原则，`"\SOH"` 会是长度为 1 的字符串，而不是 `'\SO'` 和 `'H'` 组成的字符串。但万一想要输入 `'\SO'` 和 `'H'` 怎么办呢？不是一定要分开写，可以使用特殊空字符 `'\&'`。上述的情况可以写成 `"\SO\&H"`，它的长度为 2。而 `"\&"` 等同于 `""`，`'\&'` 不合法。更多关于等效字符串的说明见 6.1.2 节。

> 注：`"\12" ++ "3"` 并不需要写成 `"\12\&3"`，不足位数的数字转义字符，可在前面补足够的 `0`，即 `"\0123"`。保持这种习惯是好的。

字符串中的“gap”是一串被两个反斜杠 `\` 包围的空白字符，整个 gap 都会被忽略。这让你能在字符串中换行，如：

```Haskell
"这里有一个反斜杠 \\ 还有一个数字转义\
	\字符 \137，和一个控制字符 \^X。"
```

字符串是字符列表的语法糖。

### 2.7    代码布局

Haskell 的语法分析依赖一系列大括号和分号，但编写程序时几乎可以全部忽略，转而通过代码布局来推断。这种特性允许你使用依赖布局方式和不依赖布局方式的两种风格的代码，甚至可以混在同一段程序中。因为布局不是必需的，其它语言的程序可以比较简单地生成 Haskell 程序。

代码布局的结果可以完全依赖分析布局本身并添加大括号和分号来产生。生成的结果不再依赖布局。

不严谨地说，插入大括号和分号的规则如下。任何一个后面不跟大括号的 `where`、`let`、`do`、`of` 关键字后，都需要遵守布局规范。这些关键字的下一个词（无论是否在新行）的缩进（即一行开头的空白符串，包括注释的长度）会被暂存，并紧接着那个关键字后面插入一个大括号。对于接下来的每一行，如果它有更多的缩进，那么上一行的最后一个部分（一个“部分”比较类似一个语句）会被延续（不插入任何东西）；如果缩进相同，那么一个新的部分开始（插入分号）；如果缩进更少，则这个布局块结束，插入一个反大括号 `}`。那个紧接在 `where`、`let`、`do`、`of` 关键字后的非大括号的词的缩进，如果没换行，它前面的代码也视为缩进。如果明确使用了大括号，那么里面的代码不会做任何布局检查。

更准确的定义见 9.3 节。

> 注：不要混用空格和制表符来缩进 Haskell 代码，最好全部用空格。也不要在缩进里面写注释。Haskell 处理相同缩进的原则是保证两行的开始位置在任何编辑器里都一致，所以混用 Tab 和空格可能会造成很麻烦的后果。就算两行缩进的 Tab 总数、空格总数都相等，顺序不一样也不一定能通过编译。

示例程序

```Haskell
module AStack( Stack, push, pop, top, size ) where
data Stack a = Empty 
             | MkStack a (Stack a)

push :: a -> Stack a -> Stack a
push x s = MkStack x s

size :: Stack a -> Int
size s = length (stkToLst s)  where
           stkToLst  Empty         = []
           stkToLst (MkStack x s)  = x:xs where xs = stkToLst s

pop :: Stack a -> (a, Stack a)
pop (MkStack x s)
  = (x, case s of r -> i r where i x = x) -- (pop Empty) is an error

top :: Stack a -> a
top (MkStack x s) = x                     -- (top Empty) is an error
```

布局分析后

```Haskell
module AStack( Stack, push, pop, top, size ) where
{data Stack a = Empty 
             | MkStack a (Stack a)

;push :: a -> Stack a -> Stack a
;push x s = MkStack x s

;size :: Stack a -> Int
;size s = length (stkToLst s)  where
           {stkToLst  Empty         = []
           ;stkToLst (MkStack x s)  = x:xs where {xs = stkToLst s

}};pop :: Stack a -> (a, Stack a)
;pop (MkStack x s)
  = (x, case s of {r -> i r where {i x = x}}) -- (pop Empty) is an error

;top :: Stack a -> a
;top (MkStack x s) = x                        -- (top Empty) is an error
}
```

## 3    表达式

本章我们将讨论 Haskell 的表达式的语法和非规范语义，包括在合适的时机介绍它们如何翻译成 Haskell 核心语言。对于 `let` 表达式，我们将同时介绍静态和动态的语义。在这些例子中的自由变量和构造器都是使用 `Prelude` 中定义的实例，例如在介绍列表推断中用到的 `concatMap` 就是指 `Prelude` 模块中定义的 `concatMap`，不管实际上那个作用域有没有定义 `concatMap`，或定义成了别的东西。

接下来的语法表达式中，有的非终结符标有上标，上标中的 `i` 代表优先级（0~9），对于 *运算符、运算符变量* 和 *运算符构造器*，它们可以同时标有结合性（`a` 代表任一，或 `l` 代表左结合，`r` 代表右结合，`n` 代表非结合）和优先级，用小括号括起二者，结合性在前和优先级在后。所以对于下面这个语法表达式：

aexp    ->  `(` exp<sup>i+1</sup> qop<sup>(a, i)</sup> `)`

它总共有30个产生式（i 有 10 种，a 有三种）*（译注：难道不是 9 x 3 = 27 种吗）*。

| 产生式                                                       | 语义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 表达式    ->  表达式<sup>0</sup> `::` [上下文 `=>`] 类型<br />                 \|  表达式<sup>0</sup> | 类型签名表达式                                               |
| 表达式<sup>i</sup>    ->  表达式<sup>i+1</sup> [具权运算符<sup>(n, i)</sup> 表达式<sup>i+1</sup>]<br />                 \|  左值表达式<sup>i</sup><br />                 \|  右值表达式<sup>i</sup> |                                                              |
| 左结合表达式<sup>i</sup>    ->  (左结合表达式<sup>i</sup> \| 左结合表达式<sup>i+1</sup>) 具权运算符<sup>(l, i)</sup> 表达式<sup>i+1</sup> |                                                              |
| 左结合表达式<sup>6</sup>   ->  `-` 左结合表达式<sup>7</sup>  |                                                              |
| 右结合表达式<sup>i</sup>    ->  表达式<sup>i+1</sup> 具权运算符<sup>(r, i)</sup> (右结合表达式<sup>i</sup> \| 表达式<sup>i+1</sup>) |                                                              |
| 表达式<sup>10</sup>    ->  `\` 绑定变量<sub>1</sub> ... 绑定变量<sub>n</sub> `->` 表达式<br />                    |  `let` 声明式 `in` 表达式<br />                    |  `if` 表达式 `then` 表达式 `else` 表达式<br />                    |  `case` 表达式 `of` { 选择肢 }<br />                    |  `do` { 语句束 }<br />                    \|  调用表达式 | lambda 表达式，n >= 1<br />let 表达式<br />条件表达式<br />case 表达式<br />do 表达式<br />函数调用 |
| 调用表达式   ->  [函数表达式] 实参表达式                     | 函数调用                                                     |
| 实参表达式   ->  具权变量<br />                       \|  普通构造器<br />                       \|  字面量<br />                       \|  `(` 表达式 `)`<br />                       |  `(` 表达式<sub>1</sub> `,` ... `,` 表达式<sub>k</sub> `)`<br />                       |  `[` 表达式<sub>1</sub> `,` ... `,` 表达式<sub>k</sub> `]`<br />                       |  `[` 表达式<sub>1</sub> [`,` 表达式<sub>2</sub>] `..` [表达式<sub>3</sub>] `]`<br />                       |  `[` 表达式 `|` 推断式<sub>1</sub> `,` ... `,` 推断式<sub>n</sub> `]`<br />                       |  `(` 表达式<sup>i+1</sup> 具权运算符<sup>(a, i)</sup> `)`<br />                       |  `(` 左结合表达式<sup>i</sup> 具权运算符<sup>(l, i)</sup> `)`<br />                       |  `(` 具权运算符<sup>(a, i)</sup><sub>&lt;`-`&gt;</sub> 表达式<sup>i+1</sup> `)`<br />                       | `(` 具权运算符<sup>(r, i)</sup><sub>&lt;`-`&gt;</sub> 右结合表达式<sup>i+1</sup> `)`<br />                       |  具权构造器 `{` 值绑定<sub>1</sub> `,` ... `,` 值绑定<sub>n</sub> `}` <br />                       |  实参表达式<sub>&lt;具权构造器&gt;</sub> `{` 值绑定<sub>1</sub> `,` ... `,` 值绑定<sub>n</sub> `}` | <br />非record的构造器表达式<br /><br />括号括起的表达式<br />元组，k >= 2<br />列表，k >= 1<br />计算数列<br />列表推断表达式，n >= 1<br />右半运算符<br />右半运算符<br />左半运算符<br />左半运算符<br />具名构造表达式，n >= 0<br />具名更新表达式，n >= 1 |

含有中缀操作符（中缀表达式或运算符）的表达式是通过结合性来消除歧义的。连续且没有括号的同优先级操作符必须是左结合或右结合的，否则将被认为是语法错误。给定表达式 " x 具名运算符<sup>(a, i)</sup> y 具名运算符<sup>(b, i)</sup> z "，当 i = j 时，只有当 a = b = l 或 a = b = r 时才不需要加括号。

负号是 Haskell 中唯一的前缀运算符，它与对应的中缀运算符——Prelude 中的减号 `-` 具有相同的优先级（见 4.4.2 节图 4.1）。

对于 lamdba 表达式、let 表达式和条件表达式，语法会存在歧义。消解这个歧义采用一个规则，即任何一个这样的表达式都尽可能地多囊括进右边的东西。



一些例子如下：

| 表达式                       | 等效表达式                       |
| ---------------------------- | -------------------------------- |
| `f x + g y`                  | `(f x) + (g y)`                  |
| `- f x + y`                  | `(- (f x)) + y`                  |
| `let {` ... `} in x + y`     | `let { ... } in (x + y)`         |
| `z + let {` ... `} in x + y` | `z + (let {` ... `} in (x + y))` |
| `f x y :: Int`               | `(f x y) :: Int`                 |
| `\ x -> a+b :: Int`          | `\ x -> ((a+b) :: Int)`          |

提示：包含 let/lambda 表达式又利用结合性的表达式可能会很难分析，例如

```Haskell
let x = True in x == x == True
```

**不可能**被解析成

```Haskell
let x = True in (x == x == True)
```

而是会被解析成

```Haskell
(let x = True in (x == x)) == True
```

因为 `(==)` 是一个非结合的运算符。

然而，有的编译器实现可能会通过在语法分析后再进行一次后处理来解决结合性问题，所以它们可能无法正确地产生以上结果。所以程序员应避免同时使用 let/lambda 表达式和非结合性的运算符。

为了清晰度，接下来的语法表达式将不再标出优先级。

### 3.1    错误

在表达式计算中出现的错误（通过 \_|\_ 表示），在 Haskell 程序中是与非终结符无法区分的。因为 Haskell 是非严格的语言，所有 Haskell 类型都包含了 \_|\_。也就是说，任意类型的值都可以根据需要而赋值为错误。当错误值被计算时，程序会被立即终止，且用户不能捕获这个错误。Prelude 提供了两个函数来实现这个功能：

```haskell
error     :: String -> a
undefined :: a
```

调用 `error` 将会立即停止程序的执行且返回一个合适的错误指示给操作系统，并且也应该在某些依赖于系统的行为中展示一个字符串。调用 `undefined` 时，错误信息是由编译器自动提供的。

Haskell 表达式使用 `error` 和 `undefined` 来显式地指出需要出现运行时异常的地方。实际的错误行为由编译器实现决定。传递给 `error` 函数的信息只是一个建议，编译器可以决定显示更多或更少的信息。

### 3.2    变量、构造器、运算符和字面量

