# Haskell 98

## 1    介绍

Haskell 是非领域性、纯函数式的编程语言，吸收了诸多近期编程语言设计的灵感。Haskell 提供高阶函数、*非严格的语义 (non-strict semantics)*、静态多态类型 (static polymorphic typing)、用户自定义计算类型、模式匹配、列表推断、模块系统、monadic的输入输出系统，还有一系列丰富的基础数据类型，包括列表、数组、任意精度和固定精度的整型，和浮点数。Haskell 是多年对于非严格函数式编程语言的研究的巅峰产物和凝结。

### 1.2    Haskell 核心语言

Haskell 吸收了许多流行的语法糖，它们可以被转化成为更简单的语法结构。如果将这种转换进行到底，得到的语言便是 Haskell 的核心语言。

Haskell 核心语言并未被形式化定义，但它可以向 Haskell 的实现者提供很好的思路。

### 1.3    值和类型

一个表达式可被计算为一个值，且具有一个静态的类型。值和类型在 Haskell 中是决然分离的。然而，Haskell 的类型系统允许多种自定义数据类型，并且不仅支持参数化多态，还支持 ad hoc 的多态，或称作 overloading（使用类型类）。

Haskell 中的错误在语义上等同于 _|_。技术上，错误与非终结符不可区分，所以语言本身并未采用任何机制来检测和应对错误。然而，Haskell 的实现会设法提供有用的错误信息。见 3.1 节。

### 1.4    命名空间

Haskell 有六种名字，代表【变量】和【构造器】的值、【类型参数】、【类型名称】、【类型类】是类型系统的实体，还有【模块名称】。名称具有以下限制：

1. 变量和类型参数的名字必须以小写字母或下划线开头，其他四种名字必须以大写字母开头；
2. 类型名必须不能与类型类的名字相同。

除此之外没有别的限制。在同一个名字域中，`Int` 既是一个模块的名字，又是一个类型类和类型的名字。

## 2    词法结构

在本章节，我们描述 Haskell 底层的词法结构。

### 2.1    符号约定

[pattern]     可省

{pattern}     重复零次或多次

(pattern)      将内容作为一个整体

pat<sub>1</sub> | pat<sub>2</sub>  多选一

pat<sub>&lt;pat'&gt;</sub>       差集—— pat 的生成元集合减去 pat' 的生成元集合

`fibonacci` 用等宽字体表示的终结符



由于本节所介绍的是词法结构，所有空白符都是被显式写出的，在两个并列相邻的符号之间没有任何默认的空格。我们使用类似 BNF 的语法来表示规则，例如

nonterm    ->  alt<sub>1</sub> | alt<sub>2</sub> | ... | alt<sub>n</sub>

必须注意区分元符号（|、 [...] 等）和终结符符号（使用等宽字体的 `|`、`[...]`）。

Haskell 使用 Unicode 字符集。Haskell 编译器应当尽可能更新以使用最新的 Unicode 标准。

### 2.2    词法程序结构

程序     ->  { 词 | 空白符 }

词         ->  具权(qualified)变量标识符 | 具权类型标识符 | 具权符号变量标识符

​               | 具权符号类型标识符 |  字面量 | 特殊符号 | 保留运算符 | 保留标识符 

字面量  ->  整数字面量 | 浮点数字面量 | 字符字面量 | 字符串字面量

特殊符号 ->  `(` | `)` | `,` | `;` | `[` | `]` | `` ` `` | `{` | `}`

空白符  ->  空白的东西 { 空白的东西 }

空白的东西 ->  空白字符 | 注释 | 多行注释

空白字符 ->  换行 | 纵向制表符 | 空格 | 制表符 | Unicode空白字符

换行      ->  CRLF | CR | LF | FF (form feed)

注释      ->  若干横杠 [ 任何字符<sub>&lt;符号&gt;</sub> {任何字符} ] 换行

​    *注：任意多个横杠接任和非符号的字符开启行内注释。*

若干横杠 ->  `--` { `-` }

开注释  ->  `{-`

关注释  ->  `-}`

多行注释 -> 开注释 任意注释字串 { 多行注释 任意注释字串 } 关注释

​    *注：这意味着 Haskell 多行注释可以嵌套。多行注释的英文原文是 nested comment，即可嵌入的注释*

任意注释字串 ->  { 任意注释字符 }<sub>&lt;{ 任意注释字符 } ( 开注释 | 闭注释  ) { 任意注释字符 }&gt;</sub>

任意注释字符 ->  可打印字符 | 空白字符

任何字符 ->  可打印字符 | 空白字符 | 制表符

可打印字符 ->  小写字母 | 大写字母 | 符号 | 数字 | 特殊符号 | `:` | `"` | `'`

小写字母 -> ASCII小写字母 | Unicode小写字母 | `_`

大写字母 -> ASCII大写字母 | Unicode大写字母

符号     -> ASCII符号 | Unicode符号<sub>&lt;特殊符号 | `_` | `:` | `"` | `'` &gt;</sub>

ASCII符号 -> `!` | `#` | `$` | `%` | `&` | `*` | `+` | `.` | `/` | `<` | `=` | `>` | `?` | `@`

​                   | `\` | `^` | `|` | `-` | `~`

数字    ->  ASCII数字 | Unicode数字

八进制整数 -> `0` | `1` | ... | `7`

十六进制整数 -> 数字 | `A` | ... | `F` | `a` | ... | `f`



词法分析应当使用“最大适合度”规则：每一次匹配，都应当读取最长可能的满足 *词* 这一条规则的词法。所以，尽管 `case` 是一个保留标识符，但 `cases` 不是。相似地，尽管 `=` 是保留运算符，但 `==` 和 `"=` 不是。

任何一种空白符都是不同词法单元之间合法的分隔符。

任何不在 *任何字符* 中的字符都是不合法的，应当导致词法错误。

>  注：字符串和单行注释中包含的 `-}` 会中断前面的多行注释。位于字符串或单行注释中的 `{-` 不会开启多行注释，因为它包含在另一个合法的词法中。

### 2.4    标识符和运算符

变量标识符    ->  ( 小写字母 {小写字母 | 大写字母 | 数字 | `'` } )<sub>&lt;保留标识符&gt;</sub>

类型标识符    ->  大写字母 {小写字母 | 大写字母 | 数字 | `'`}

保留标识符    ->  `case` | `class` | `data` | `default` | `deriving` | `do` | `else`

​                        |  `if` | `import` | `in` | `infix` | `infixl` | `infixr` | `instance`

​                        |  `let` | `module` | `newtype` | `of` | `then` | `type` | `where` | `_`

符号变量标识符 ->  ( 符号 {符号 | `:`} )<sub>&lt;保留运算符 | 若干横杠&gt;</sub>

符号类型标识符 ->  (`:` {符号 | `:`})<sub>&lt;保留运算符&gt;</sub>

保留运算符    ->  `..` | `:` | `::` | `=` | `\` | `|` | `<-` | `->` | `@` | `~` | `=>`

除了特殊的负号语法规则，所有运算符都是中缀的。当然，运算符可以用括号括起而当作一个 *section*，产生部分应用的运算符。所有标准中缀运算符都只是预定义的符号，可以被重新绑定。



由词法分类到前述的六种名字类型如下所示：

| -          | ->   | -        |
| ---------- | ---- | -------- |
| 变量标识符 | ->   | 变量     |
| 类型标识符 | ->   | 构造器   |
| 变量标识符 | ->   | 类型参数 |
| 类型标识符 | ->   | 类型名称 |
| 类型标识符 | ->   | 类型类   |
| 类型标识符 | ->   | 模块名称 |

只有变量和构造器具有中缀形式，其他没有。



具权(qualified)名称：变量、构造器、类型名称和类型类可以具有一个模块名作为前缀：

| -              | ->   | -                           |
| -------------- | ---- | --------------------------- |
| 具权变量       | ->   | [模块标识符 `.`] 变量       |
| 具权构造器     | ->   | [模块标识符 `.`] 构造器     |
| 具权类型名     | ->   | [模块标识符 `.`] 类型名     |
| 具权类型参数   | ->   | [模块标识符 `.`] 类型参数   |
| 具权符号变量   | ->   | [模块标识符 `.`] 符号变量   |
| 具权符号构造器 | ->   | [模块标识符 `.`] 符号构造器 |

因为具权名称是一个单独的词法，在模块标识符和名称之间不允许有空白符。